using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using LeagueSharp;
using LeagueSharp.Common;
using System.Drawing;
using SharpDX;

namespace RyzePassiveExploit
{
    class Program
    {
        private static Obj_AI_Hero Player;
        private static Menu Config;
        private static Spell W, E;

        static void Main(string[] args)
        {
            CustomEvents.Game.OnGameLoad += GameOnOnGameLoad;
        }

        private static void GameOnOnGameLoad(EventArgs args)
        {

            Player = ObjectManager.Player;

            W = new Spell(SpellSlot.W, 600);
            E = new Spell(SpellSlot.E, 600);

            Config = new Menu("RyzExploit", "RyzExploit", true);
            Config.AddItem(new MenuItem("enabled", "Enabled").SetValue(new KeyBind('Z', KeyBindType.Toggle)));
            Config.AddItem(new MenuItem("draw", "Draw status").SetValue(true));
            Config.AddItem(new MenuItem("slider", "Slider").SetValue(new Slider(100, -200, 400)));
            Config.AddItem(new MenuItem("info", "If casting W/E too late, increase slider. Vice versa."));

            Config.AddToMainMenu();
            Game.OnUpdate += Game_OnUpdate;
            Drawing.OnDraw += Drawing_OnDraw;
        }

        static void Drawing_OnDraw(EventArgs args)
        {
            if (Player.IsDead)
                return;

            var heropos = Drawing.WorldToScreen(ObjectManager.Player.Position);

            if (Config.Item("draw").GetValue<bool>())
            {
                if (Config.Item("enabled").IsActive())
                {
                    Drawing.DrawText(heropos.X, heropos.Y + 15, System.Drawing.Color.White, "RyzExploit enabled");
                }
            }
        }

        static void Game_OnUpdate(EventArgs args)
        {
            if (Player.IsDead)
                return;

            if (!Config.Item("enabled").IsActive())
                return;

            var minions = (MinionManager.GetMinions(W.Range, MinionTypes.All, MinionTeam.Enemy));
            
            foreach (var minion in minions)
            {
                var t = (int)(Player.AttackCastDelay * 1000) - 100 + Game.Ping / 2 + 1000 * (int)Player.Distance(minion.Position) / (int)Player.BasicAttack.MissileSpeed;

                var predHealth = HealthPrediction.GetHealthPrediction(minion, t);

                if (Player.TotalAttackDamage >= predHealth)
                {
                    if (Player.IsWindingUp)
                    {
                        if (W.IsReady())
                        {
                            Utility.DelayAction.Add(t - Config.Item("slider").GetValue<Slider>().Value, () => W.CastOnUnit(minion));
                        }

                        else if (E.IsReady())
                        {
                            Utility.DelayAction.Add(t - Config.Item("slider").GetValue<Slider>().Value, () => E.CastOnUnit(minion));
                        }
                    }
                }
            }
        }      
    }
}
